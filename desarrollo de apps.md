El desarrollo de aplicaciones (o "Desarrollo de apps") a menudo se asocia con el concepto de vibe coding, que, según Sean Kochel, ha sido malinterpretado. La narrativa común presenta el vibe coding como sinónimo de falta de atención o irreflexión, llevando a fallos de seguridad, juegos mal codificados o aplicaciones poco impresionantes.  
Sin embargo, Sean Kochel propone una distinción crucial: el vibe coding significa "construir sin la sintaxis del lenguaje", pero "no significa construir sin pensar en lo que estás construyendo". Para él, se trata de entender la importancia de tener un sistema para manejar grandes volúmenes de usuarios o la necesidad de un pipeline de despliegue, incluso si no se puede configurar una caché de Redis desde cero.  
Para asegurar un proceso de construcción reflexivo y efectivo en el desarrollo de aplicaciones, Sean Kochel emplea una serie de "agentes" o "prompts" que simulan un equipo de producto completo. Estos prompts garantizan una reflexión profunda en cada etapa del desarrollo. A continuación, se detallan los cinco prompts principales que considera esenciales para cualquier desarrollador, especialmente cuando se utiliza la codificación asistida por IA:  
1\. Product Manager Prompt (Prompt de Gerente de Producto) Este prompt es fundamental para definir qué se está construyendo, por qué y cómo se medirá el éxito. Transforma una idea inicial en un plan de producto estructurado y accionable. Su enfoque principal es identificar el problema fundamental que la aplicación resolverá. El resultado incluye:  
    ◦ Resumen ejecutivo: Un "elevator pitch" de una frase, la declaración del problema central, la audiencia objetivo, la diferenciación del producto y cómo se medirá el éxito.  
    ◦ Especificaciones detalladas de características: Para cada característica, se define su nombre, la historia de usuario principal (ej: "Como \[rol\], quiero \[acción\] para poder \[beneficio\]") y los requisitos funcionales específicos. Un ejemplo de esto es la creación de una extensión de Chrome llamada Color IQ, que ayuda a los usuarios a combinar prendas de vestir con su "estación de color" personal, resolviendo el problema de que los compradores online gastan dinero en ropa que no les sienta bien. Este prompt asegura que se detalla todo antes de construir, incluyendo la gestión de estados y las integraciones con otras partes de la aplicación.  
2\. UX Engineer Prompt (Prompt de Ingeniero de Experiencia de Usuario) Este prompt se centra en diseñar la experiencia de usuario y las interfaces visuales. Su objetivo es traducir las historias de usuario del Product Manager en sistemas de diseño completos, flujos de usuario detallados y especificaciones listas para la implementación. Al separar el trabajo de diseño de la codificación, se obtiene un diseño de mucha mejor calidad, ya que el modelo de lenguaje puede concentrarse plenamente en la tarea de diseño. Incluye:  
    ◦ Filosofía de diseño cohesiva: Como "simplicidad audaz", "espacios en blanco transpirables", y la aplicación sistemática de la teoría del color.  
    ◦ Principios de UX: Reflexionando sobre el objetivo principal de cada pantalla, cómo presentar la información de la mejor manera y cómo revelar elementos gradualmente.  
    ◦ Sistema de diseño completo: Incluyendo tokens de color, tipografía, espaciado, componentes compartidos y específicos de características, y el sistema de movimiento y animación. Para la extensión Color IQ, este prompt generaría maquetas visuales detalladas, estados de éxito y error, y la posición de los elementos en la pantalla, como un indicador de porcentaje de coincidencia en la esquina superior derecha de una imagen de producto. También crea un sistema de documentación robusto para que los desarrolladores y el modelo de lenguaje sepan cómo usar estos elementos.  
3\. System Architect Prompt (Prompt de Arquitecto de Sistemas) Una vez que se tiene una comprensión clara de lo que hará la aplicación, este prompt aborda cómo lo hará. Ayuda a definir las elecciones técnicas y las compensaciones necesarias para entregar las características planificadas. Es crucial para planificar con anticipación cómo la aplicación manejará el crecimiento (ej: 500 usuarios subiendo imágenes simultáneamente) para evitar fallas. Cubre:  
    ◦ Infraestructura subyacente: Decidiendo la pila tecnológica para el frontend y el backend (ej: React Native con Expo para frontend, FastAPI para backend).  
    ◦ Modelo de datos y API: Cómo se modelarán los datos y se interactuará con ellos, y cómo debería ser la API.  
    ◦ Integración con servicios de terceros: Como OpenAI para IA o Cloudinary para almacenamiento de imágenes.  
    ◦ Seguridad y rendimiento: Consideraciones para el manejo de usuarios activos y tiempos de respuesta. Un ejemplo es la aplicación Forkcast, una aplicación de cocina que utiliza IA para recrear comidas a partir de imágenes. Para esta app, el prompt definió una arquitectura con React Native, FastAPI, Supabase, OpenAI y Railway para el despliegue, incluyendo detalles como el manejo de imágenes de hasta 5MB y un tiempo de respuesta de IA de 30-60 segundos para la generación de recetas, y la capacidad de manejar 10,000 usuarios activos. También considera la necesidad de capas de caché (Redis) para manejar picos de solicitudes.  
4\. Wrecking Ball Prompt (Prompt de Bola Demoledora) Este prompt actúa como un especialista en validación de requisitos meticuloso. Su propósito es comparar lo que se pretendía construir (según los requisitos del Product Manager y el UX Engineer) con lo que se construyó realmente. Es vital porque los modelos de IA a veces construyen funcionalidades avanzadas pero omiten la conexión con otras partes de la aplicación. Utiliza un sistema de tres niveles para validar:  
    ◦ Requisitos: Identifica si todo lo especificado fue construido, y si se construyó algo no solicitado.  
    ◦ Comportamiento previsto: Evalúa qué tan bien se implementó el comportamiento deseado frente a lo que se construyó.  
    ◦ Recorridos de usuario: Asegura que cada parte de los recorridos de usuario esté implementada con calidad y tenga sentido. Para el proyecto Forkcast, este prompt reveló que solo se había completado el 62% de los requisitos, identificando lagunas en la autenticación, la generación de recetas (problemas de tiempo de procesamiento, falta de notificaciones) y la gestión del historial de recetas. Ayuda a identificar las omisiones críticas que necesitan ser corregidas para que la aplicación funcione como se desea.  
5\. UI Polisher Prompt (Prompt de Pulidor de UI) Incluso si la aplicación cumple con las especificaciones técnicas, a veces la interfaz de usuario no es atractiva. Este prompt permite evaluar el rendimiento actual de la UI contra las especificaciones de diseño originales (definidas por el UX Engineer) para encontrar puntos específicos donde el sistema necesita ser ajustado y pulido. Al separar la codificación del diseño, se obtienen mejores resultados. El prompt ayuda a identificar:  
    ◦ Aplicación inconsistente del sistema de diseño: Asegura que los tokens y estilos definidos se apliquen correctamente en toda la aplicación.  
    ◦ Mejoras visuales: Como implementar sombras, gradientes, profundidad, mejorar la tipografía y el flujo visual.  
    ◦ Interacciones premium: Pequeñas microinteracciones que hacen que la aplicación se sienta más viva y pulida. En el caso de Forkcast, este prompt podría señalar que, aunque hay un sistema de diseño técnico sólido, la implementación es inconsistente, con diferentes estilos en distintas secciones de la app, lo que resulta en una experiencia visual menos pulida. El resultado es una lista de mejoras críticas que pueden ser alimentadas a un agente de ingeniería frontend para realizar los cambios y refinar la interfaz.  
En resumen, el desarrollo de aplicaciones mediante "vibe coding" no debe ser un proceso sin sentido. Al seguir un proceso estructurado con estos prompts, se simula un equipo de producto completo, asegurando que se piense profundamente en cada aspecto de la aplicación, desde la idea inicial hasta los detalles técnicos y el pulido final, lo que lleva a la creación de soluciones significativas y de alta calidad. La clave no está en las herramientas, sino en el proceso que se sigue